# 第四周：并发编程题目

**题目 01- 请你说一说什么是线程和进程？**

- 区别

  - 进程：是分配资源的最小单位，如内存，网卡，等设备
  - 线程：是CPU调度的最小单位

- 关系

  一个进程内的多个线程共享进程的内存空间和打开的文件设备

- 线程的上下文切换是什么？

  当期获取CPU的线程因为各种原因（CPU时间片到期 等待事件阻塞自身 睡眠）要释放CPU时，需要保存线程执行的上下文：即寄存器中的信息 到线程栈中，根据线程调度策略，操作系统拿到下一个准备执行线程的数据结构，获取线程栈中之前存储的寄存器的信息，恢复到寄存器中，然后下一个线程执行

- 线程的并发与并行有啥区别？

  - 并发：是同一个时间段内交替执行多个任务 单核CPU也能做到
  - 并行：同一个时刻内 执行多个任务（需要多核CPU的支持）

**题目 02- 使用了多线程会带来什么问题呢？**

- 能不能详细说说线程安全问题？

  是由于多个线程并发访问和修改共享数据导致的

  因为修改共享数据的过程 不是一个原子性操作 

  而是3个操作（忽略CPU缓存）

  1. 将数据从内存读到寄存器
  2. CPU修改寄存器中的值
  3. 将寄存器中的值修改到内存中

  这3个操作 需要是一个原子操作 才能保证数据在多线程的情况下是正确修改 最终值符合预期的（跟单线程执行的效果一样）

- 原子性、有序性和可见性能不能深入的谈一下。

  本质上是由于硬件层面的优化导致的

  - 原子性：因为要发挥多核CPU的作用，导致了并发修改共享数据时，需要将一组操作设置为原子性操作，这一组操作要么同时生效，要么不生效
  - 有序性：因为编译器优化导致计算机指令重排序，导致最终程序的二进制文件中的指令与程序中的代码顺序不完全一致
  - 可见性：因为要CPU访问内存的速度比较慢，所以硬件层面在寄存器与内存之间，加了多级缓存，有的缓存是CPU私有的，这样就会导致分散在不同CPU缓存中的数据不一致的现象

**题目 03- 什么是死锁？如何排查死锁?**
排查过程最好详细说明，最少说一种排查方案，越多越好。

死锁：一个线程持有A资源 请求B资源  另一个先持有B资源 请求A资源 导致互相等待 两个线程都无法继续执行下去的情况



排查：

1. jstack找出block在锁的线程
2. 借助arthas工具 找出死锁线程
3. 查看代码逻辑排查