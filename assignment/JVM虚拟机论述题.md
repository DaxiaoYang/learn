# JVM虚拟机论述题



## 题目 01- 请你用自己的语言向我介绍 Java 运行时数据区（内存区域）

**内存划分**：

- 线程私有部分有：

  - PC：指向下一个要执行的虚拟机指令

  - 虚拟机栈：存储运行在JVM之上的应用程序中的方法对应的栈帧

  - 本地方法栈：存储C++/C 语言方法（JNI调用会触发）对应的栈帧

- 线程共享部分：
  - 堆：分配对象内存
  - 方法区：存储类相关的元信息
  - 直接内存：一般用于网络IO中转，少一次JVM堆-本地堆之间的数据拷贝



**堆内存划分年轻代和老年代的原因**

基于两个假说：

- 大部分对象都是朝生夕死
- 熬过越多次GC的对象 越不会被GC

所以可以采用不同的垃圾回收算法，减少垃圾回收时的工作量

年轻代：采用标记复制，只找到少数的存活的对象，将其复制到survivor区即可

老年代：采用标记清理/整理，只需要处理少数死亡的对象即可



## 题目 02- 描述一个 Java 对象的生命周期

**对象创建过程**：

1. 检查对象对应的类是否加载，没有加载的话就先去加载类
2. 为对象分配内存：一般是在堆中线程对应的TLAB中分配，TLAB满了就去CAS跟堆中其他申请内存的线程争抢分配内存，如果被逃逸分析优化（对象生命周期都在栈内且其他地方没有引用）的话，也可能是在栈上分配的
3. 为对象赋初值
4. 返回对象的引用



**对象内存分配**

见上道题的2



**对象的销毁过程**

1. 被垃圾回收算法标记为垃圾
2. 自救阶段 finalize()方法中 没有让其他GC Roots强引用自己
3. 被垃圾回收



**对象的两种访问方式**

- 引用指向的是逻辑句柄，先访问逻辑句柄，再通过对应关系，访问到堆中的对象首地址
- 引用直接指向堆中的对象首地址



**为什么需要内存担保**

因为当新生代survivor区不够内存空间存放本轮young GC后的存活对象时，还不能判断出是否是整个堆的空间都不够，老年代可能还有剩余的空间，所以此时报OOM错误不合理，所以尝试将存活对象放入老年区，老年区空间不够，进行3次Full GC，之后如果空间不够，才能说明整个堆空间确实不够，此时可以报OOM错误。



## 题目 03- 垃圾收集算法有哪些？垃圾收集器有哪些？他们的特点是什么？

**垃圾收集算法**：

- 标记复制
- 标记清理
- 标记整理



**垃圾收集器**

没怎么记

服务器的方案一般是下面：（客户端/单核系统/系统资源吃紧的环境一般会考虑单线程的垃圾回收器）

- 方案1：Parallel New + CMS

  - Parallel Scavenge：新生代 标记复制 多线程 
  - CMS：老年代 标记清理 停顿时间短（分为初始标记 并发标记 重新标记 并发清理 4个阶段 只有初始标记（标记GC Roots）和重新标记阶段需要Stop the World）

- 方案2：G1

  分块的思想，逻辑上新生代/老年代还存在，但是物理上内存被划分为一个个region，每次会回收最有价值（收集器自己判定）的部分，避免一次回收范围过大，造成长时间的STW

  